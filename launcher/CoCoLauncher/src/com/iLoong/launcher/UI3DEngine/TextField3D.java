/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.iLoong.launcher.UI3DEngine;

import java.util.List;

import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.FontMetrics;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Group;
import com.badlogic.gdx.scenes.scene2d.ui.TextField;
import com.badlogic.gdx.scenes.scene2d.ui.utils.Clipboard;
import com.iLoong.launcher.Desktop3D.R3D;

/**
 * A single-line text input field.
 * <p>
 * The preferred height of a text field is the height of the
 * {@link TextFieldStyle#font} and {@link TextFieldStyle#background}. The
 * preferred width of a text field is 150, a relatively arbitrary size.
 * <p>
 * The text field will copy the currently selected text when ctrl+c is pressed,
 * and paste any text in the clipboard when ctrl+v is pressed. Clipboard
 * functionality is provided via the {@link Clipboard} interface. Currently
 * there are two standard implementations, one for the desktop and one for
 * Android. The Android clipboard is a stub, as copy & pasting on Android is not
 * supported yet.
 * <p>
 * The text field allows you to specify an {@link OnscreenKeyboard} for
 * displaying a softkeyboard and piping all key events generated by the keyboard
 * to the text field. There are two standard implementations, one for the
 * desktop and one for Android. The desktop keyboard is a stub, as a
 * softkeyboard is not needed on the desktop. The Android
 * {@link OnscreenKeyboard} implementation will bring up the default IME.
 * 
 * @author mzechner
 */
public class TextField3D extends View3D {
	static private final char BACKSPACE = 8;
	static private final char ENTER_DESKTOP = '\r';
	static private final char ENTER_ANDROID = '\n';
	static private final char TAB = '\t';
	static private final char DELETE = 127;
	static private final char BULLET = 149;

	private String text = "";
	private String messageText;
	private String displayText;
	private int cursor;
	private Clipboard clipboard;
	private TextFieldListener listener;
	private TextFieldFilter filter;
	private OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard();
	private DisplayTextFormatter textFormater = new DefaultTextureDefaultFormatter();
	private KeyboardAdapter keyboardAdapter = null;

	private boolean passwordMode;
	private StringBuilder passwordBuffer;

	private int visibleTextEnd;

	private boolean cursorOn = true;
	private float blinkTime = 0.42f;
	private long lastBlink;

	private boolean hasSelection;
	private int selectionStart;
	private char passwordCharacter = BULLET;
	private NinePatch cursorPatch = null;
	private TextureRegion displayTextTexture;
	private Paint paint;
	float cursorHeight = 0f;
	private boolean editable = false;
	private boolean openAction = false;

	public boolean isOpenAction() {
		return openAction;
	}

	public void setOpenAction(boolean openAction) {
		this.openAction = openAction;
	}

	/**
	 * @param messageText
	 *            Text to show when empty. May be null.
	 */
	private TextField3D() {
		super("text_field");
	}

	public TextField3D(String name, float width, float height, Paint paint) {
		super(name);
		if (paint == null)
			throw new IllegalArgumentException("paint cannot be null.");
		this.width = width;
		this.height = height;
		this.paint = paint;
		cursorPatch = new NinePatch(R3D.findRegion("cursor_patch"), 1, 1, 0, 0);
		this.clipboard = Clipboard.getDefaultClipboard();
		cursorHeight = (float) Math.ceil(paint.getFontMetrics().descent
				- paint.getFontMetrics().ascent);
		textFormater.setPaint(paint);
	}

	public KeyboardAdapter getKeyboardAdapter() {
		return keyboardAdapter;
	}

	public void setKeyboardAdapter(KeyboardAdapter keyboardAdapter) {
		this.keyboardAdapter = keyboardAdapter;
	}

	public void setPasswordCharacter(char passwordCharacter) {
		this.passwordCharacter = passwordCharacter;
	}

	private void calculateOffsets() {
		if (displayText != null && displayText.length() > 0) {
			visibleTextEnd = (int) paint.measureText(displayText);
		} else {
			visibleTextEnd = 0;
		}
	}

	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		super.draw(batch, parentAlpha);
		batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
		boolean focused = stage != null && stage.getKeyboardFocus() == this;
		if (displayTextTexture != null) {
			batch.draw(displayTextTexture, x, y);
		}
		if (focused && editable) {
			blink();
			if (cursorOn && cursorPatch != null) {
				cursorPatch.draw(batch, x + visibleTextEnd, y
						+ (this.height - cursorHeight) / 2,
						cursorPatch.getTotalWidth(), cursorHeight);
			}
			Gdx.graphics.requestRendering();
		}
	}

	public boolean isEditable() {
		return editable;
	}

	public void setEditable(boolean editable) {
		this.editable = editable;
	}

	@Override
	public boolean onClick(float x, float y) {
		// TODO Auto-generated method stub
		return false;
	}

	public void clear() {
		this.text = "";
		updateDisplayText();
		cursor = 0;
		if (listener != null) {
			listener.valueChanged(this, text);
		}
	}

	private void updateDisplayText() {
		if (passwordMode) {
			if (passwordBuffer == null)
				passwordBuffer = new StringBuilder(text.length());
			if (passwordBuffer.length() > text.length()) //
				passwordBuffer.setLength(text.length());
			else {
				for (int i = passwordBuffer.length(), n = text.length(); i < n; i++)
					passwordBuffer.append(passwordCharacter);
			}
			displayText = passwordBuffer.toString();
		} else
			displayText = text;

		displayText = textFormater.formatDisplayTitle(displayText, (int) width,
				(int) height);
		calculateOffsets();
		Texture oldTexture = null;
		if (this.displayTextTexture != null
				&& displayTextTexture.getTexture() != null) {
			oldTexture = displayTextTexture.getTexture();
			TextureRegion newRegion = textFormater.getDisplayTexture(
					displayText, (int) width, (int) height);
			// titleToTexture(displayText.toString(), (int) width, (int)
			// height);
			displayTextTexture.setRegion(newRegion);
			if (oldTexture != null) {
				oldTexture.dispose();
			}
		} else {
			displayTextTexture = textFormater.getDisplayTexture(displayText,
					(int) width, (int) height);
			// titleToTexture(this.displayText.toString(),
			// (int) this.width, (int) this.height);
		}
	}

	private void blink() {
		long time = System.nanoTime();
		if ((time - lastBlink) / 1000000000.0f > blinkTime) {
			cursorOn = !cursorOn;
			lastBlink = time;
		}
	}

	@Override
	public boolean onTouchDown(float x, float y, int pointer) {
		// TODO Auto-generated method stub
		if (editable) {
			if (pointer != 0)
				return false;
			if (stage != null)
				stage.setKeyboardFocus(this);
			keyboard.show(true);
			if (keyboardAdapter != null) {
				keyboardAdapter.onKeyboardOpen(this);
			}
			openAction = true;
			clearSelection();
			lastBlink = 0;
			cursorOn = false;
			return true;
		} else {
			return false;
		}
	}

	public void popKeyBoard() {
		if (stage != null)
			stage.setKeyboardFocus(this);
		keyboard.show(true);
		if (keyboardAdapter != null) {
			keyboardAdapter.onKeyboardOpen(this);
		}
		clearSelection();
		lastBlink = 0;
		cursorOn = false;
	}

	public void showInputKeyboard()
	{
		if (editable) 
		{
			if (stage != null)
				stage.setKeyboardFocus(this);
			keyboard.show(true);
			if (keyboardAdapter != null) {
				keyboardAdapter.onKeyboardOpen(this);
			}
			openAction = true;
			clearSelection();
			lastBlink = 0;
			cursorOn = false;
		}
	}
	public void hideInputKeyboard() {
		if (stage != null)
			stage.setKeyboardFocus(null);
		if (keyboardAdapter != null) {
			keyboardAdapter.onKeyboardClose(this);
		}
		keyboard.show(false);
		lastBlink = 0;
		cursorOn = false;
	}

	public boolean keyDown(int keycode) {
		if (stage != null && stage.getKeyboardFocus() == this) {
			if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)
					|| Gdx.input.isKeyPressed(Keys.CONTROL_RIGHT)) {
				// paste
				if (keycode == Keys.V)
					paste();
				// copy
				if (keycode == Keys.C || keycode == Keys.INSERT)
					copy();
			} else if (Gdx.input.isKeyPressed(Keys.SHIFT_LEFT)
					|| Gdx.input.isKeyPressed(Keys.SHIFT_RIGHT)) {
				// paste
				if (keycode == Keys.INSERT)
					paste();
				// cut
				if (keycode == Keys.FORWARD_DEL) {
					if (hasSelection) {
						copy();
						delete();
					}
				}
				// selection
				if (keycode == Keys.LEFT) {
					if (!hasSelection) {
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor--;
				}
				if (keycode == Keys.RIGHT) {
					if (!hasSelection) {
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor++;
				}
				if (keycode == Keys.HOME) {
					if (!hasSelection) {
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor = 0;
				}
				if (keycode == Keys.END) {
					if (!hasSelection) {
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor = text.length();
				}

				cursor = Math.max(0, cursor);
				cursor = Math.min(text.length(), cursor);
			} else {
				// cursor movement or other keys (kill selection)
				if (keycode == Keys.LEFT) {
					cursor--;
					clearSelection();
				}
				if (keycode == Keys.RIGHT) {
					cursor++;
					clearSelection();
				}
				if (keycode == Keys.HOME) {
					cursor = 0;
					clearSelection();
				}
				if (keycode == Keys.END) {
					cursor = text.length();
					clearSelection();
				}

				// cursor = Math.max(0, cursor);
				// cursor = Math.min(text.length(), cursor);
			}

			return true;
		}
		return false;
	}

	@Override
	public boolean keyUp(int keycode) {
		// TODO Auto-generated method stub
		if (keycode == android.view.KeyEvent.KEYCODE_BACK) {
			hideInputKeyboard();
			openAction = false;
			return true;
		}
		return false;
	}

	private void copy() {
		if (hasSelection) {
			int minIndex = Math.min(cursor, selectionStart);
			int maxIndex = Math.max(cursor, selectionStart);
			clipboard.setContents(text.substring(minIndex, maxIndex));
		}
	}

	private void paste() {
		String content = clipboard.getContents();
		if (content != null) {
			StringBuilder builder = new StringBuilder();
			for (int i = 0; i < content.length(); i++) {
				char c = content.charAt(i);
				builder.append(c);
			}
			content = builder.toString();
			text = text.substring(0, cursor) + content
					+ text.substring(cursor, text.length());
			updateDisplayText();
			cursor += content.length();
		}
	}

	private void delete() {
		int minIndex = Math.min(cursor, selectionStart);
		int maxIndex = Math.max(cursor, selectionStart);
		text = (minIndex > 0 ? text.substring(0, minIndex) : "")
				+ (maxIndex < text.length() ? text.substring(maxIndex,
						text.length()) : "");
		updateDisplayText();
		cursor = minIndex;
		clearSelection();
	}

	public boolean keyTyped(char character) {

		if (stage != null && stage.getKeyboardFocus() == this && editable) {
			if (character == BACKSPACE) {
				if ((cursor > 0 || hasSelection)) {
					if (!hasSelection) {
						text = text.substring(0, cursor - 1)
								+ text.substring(cursor);
						updateDisplayText();
						cursor--;
					} else {
						delete();
					}
				}
			}
			if (character == DELETE) {
				if (cursor < text.length() || hasSelection) {
					if (!hasSelection) {
						text = text.substring(0, cursor)
								+ text.substring(cursor + 1);
						updateDisplayText();
					} else {
						delete();
					}
				}
				return true;
			}
			if (character != ENTER_DESKTOP && character != ENTER_ANDROID) {
				if (filter != null && !filter.acceptChar(this, character))
					return true;
			}
			if (character == TAB || character == ENTER_ANDROID)
				next(Gdx.input.isKeyPressed(Keys.SHIFT_LEFT)
						|| Gdx.input.isKeyPressed(Keys.SHIFT_RIGHT));

			if (!hasSelection) {
				if (String.valueOf(character).trim().length() > 0) {
					text = text.substring(0, cursor) + character
							+ text.substring(cursor, text.length());
					updateDisplayText();
					cursor++;
				}
			} else {
				if (String.valueOf(character).trim().length() > 0) {
					int minIndex = Math.min(cursor, selectionStart);
					int maxIndex = Math.max(cursor, selectionStart);

					text = (minIndex > 0 ? text.substring(0, minIndex) : "")
							+ (maxIndex < text.length() ? text.substring(
									maxIndex, text.length()) : "");
					cursor = minIndex;
					text = text.substring(0, cursor) + character
							+ text.substring(cursor, text.length());
					updateDisplayText();
					cursor++;
					clearSelection();
				}
			}
			if (character == '\0') {
				//Log.e("test", "empty character");
			} else {
				if (listener != null)
					listener.valueChanged(this, text);
			}
			return true;
		} else
			return false;
	}

	public boolean keyTyped(String characters) {

		if (stage != null && stage.getKeyboardFocus() == this && editable) {
			if (characters == null
					|| String.valueOf(characters).trim().length() == 0) {
				return true;
			}
			if (!hasSelection) {
				text = text.substring(0, cursor) + characters.trim()
						+ text.substring(cursor, text.length());
				updateDisplayText();
				cursor = cursor + characters.trim().length();
			} else {
				int minIndex = Math.min(cursor, selectionStart);
				int maxIndex = Math.max(cursor, selectionStart);

				text = (minIndex > 0 ? text.substring(0, minIndex) : "")
						+ (maxIndex < text.length() ? text.substring(maxIndex,
								text.length()) : "");
				cursor = minIndex;
				text = text.substring(0, cursor) + characters.trim()
						+ text.substring(cursor, text.length());
				updateDisplayText();
				cursor = cursor + characters.trim().length();
				clearSelection();
			}
			if (listener != null)
				listener.valueChanged(this, text);
			return true;
		} else
			return false;
	}

	/**
	 * Focuses the next TextField. If none is found, the keyboard is hidden.
	 * Does nothing if the text field is not in a stage.
	 * 
	 * @param up
	 *            If true, the TextField with the same or next smallest y
	 *            coordinate is found, else the next highest.
	 */
	public void next(boolean up) {
		if (stage == null)
			return;
		TextField3D textField = findNextTextField(stage.getActors(), null, up);
		if (textField != null)
			stage.setKeyboardFocus(textField);
		else
			Gdx.input.setOnscreenKeyboardVisible(false);
	}

	private TextField3D findNextTextField(List<Actor> actors, TextField3D best,
			boolean up) {
		for (int i = 0, n = actors.size(); i < n; i++) {
			Actor actor = actors.get(i);
			if (actor instanceof TextField3D) {
				if (actor == this)
					continue;
				if (actor.y == y) {
					if (best == null && actor.x >= x ^ up)
						best = (TextField3D) actor;
				} else if (actor.y < y ^ up
						&& (best == null || actor.y - y > best.y - y ^ up)) {
					best = (TextField3D) actor;
				}
			}
			if (actor instanceof Group)
				best = findNextTextField(((Group) actor).getActors(), best, up);
		}
		return best;
	}

	/**
	 * @param listener
	 *            May be null.
	 */
	public void setTextFieldListener(TextFieldListener listener) {
		this.listener = listener;
	}

	/**
	 * @param filter
	 *            May be null.
	 */
	public void setTextFieldFilter(TextFieldFilter filter) {
		this.filter = filter;
	}

	/** @return May be null. */
	public String getMessageText() {
		return messageText;
	}

	/**
	 * Sets the text that will be drawn in the text field if no text has been
	 * entered.
	 * 
	 * @parma messageText May be null.
	 */
	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	/** @return Never null, might be an empty string. */
	public String getText() {
		return text;
	}

	public String getDisplayText() {
		return displayText;
	}

	/** Sets the selected text. */
	public void setSelection(int selectionStart, int selectionEnd) {
		if (selectionStart < 0)
			throw new IllegalArgumentException("selectionStart must be >= 0");
		if (selectionEnd < 0)
			throw new IllegalArgumentException("selectionEnd must be >= 0");
		selectionStart = Math.min(text.length(), selectionStart);
		selectionEnd = Math.min(text.length(), selectionEnd);
		if (selectionEnd == selectionStart) {
			clearSelection();
			return;
		}
		if (selectionEnd < selectionStart) {
			int temp = selectionEnd;
			selectionEnd = selectionStart;
			selectionStart = temp;
		}

		hasSelection = true;
		this.selectionStart = selectionStart;
		cursor = selectionEnd;
	}

	public void clearSelection() {
		hasSelection = false;
	}

	/** Sets the cursor position and clears any selection. */
	public void setCursorPosition(int cursorPosition) {
		if (cursorPosition < 0)
			throw new IllegalArgumentException("cursorPosition must be >= 0");
		clearSelection();
		cursor = Math.min(cursorPosition, text.length());
	}

	public int getCursorPosition() {
		return cursor;
	}

	/** Default is an instance of {@link DefaultOnscreenKeyboard}. */
	public OnscreenKeyboard getOnscreenKeyboard() {
		return keyboard;
	}

	public void setOnscreenKeyboard(OnscreenKeyboard keyboard) {
		this.keyboard = keyboard;
	}

	public void setClipboard(Clipboard clipboard) {
		this.clipboard = clipboard;
	}

	/**
	 * If true, the text in this text field will be shown as bullet characters.
	 * The font must have character 149 or this will have no affect.
	 */
	public void setPasswordMode(boolean passwordMode) {
		this.passwordMode = passwordMode;
	}

	/**
	 * Interface for listening to typed characters.
	 * 
	 * @author mzechner
	 */
	static public interface TextFieldListener {
		public void valueChanged(TextField3D textField, String newValue);
	}

	/**
	 * Interface for filtering characters entered into the text field.
	 * 
	 * @author mzechner
	 */
	static public interface TextFieldFilter {
		/**
		 * @param textField
		 * @param key
		 * @return whether to accept the character
		 */
		public boolean acceptChar(TextField3D textField, char key);

		static public class DigitsOnlyFilter implements TextFieldFilter {
			@Override
			public boolean acceptChar(TextField3D textField, char key) {
				return Character.isDigit(key);
			}

		}
	}

	/**
	 * An interface for onscreen keyboards. Can invoke the default keyboard or
	 * render your own keyboard!
	 * 
	 * @author mzechner
	 */
	static public interface OnscreenKeyboard {
		public void show(boolean visible);
	}

	static public interface KeyboardAdapter {
		public void onKeyboardOpen(View3D keyboardFocusView);

		public void onKeyboardClose(View3D keyboardFocusView);
	}

	static public interface DisplayTextFormatter {
		public void setPaint(Paint paint);

		public TextureRegion getDisplayTexture(String title, int width,
				int height);

		public String formatDisplayTitle(String title, int width, int height);
	}

	static public class DefaultTextureDefaultFormatter implements
			DisplayTextFormatter {
		public Paint paint;

		@Override
		public TextureRegion getDisplayTexture(String displayTitle,
				int titleWidth, int titleHeight) {
			// TODO Auto-generated method stub
			if (paint == null) {
				throw new IllegalArgumentException("paint cannot be null.");
			}
			Bitmap bmp = Bitmap.createBitmap(titleWidth, titleHeight,
					Config.ARGB_8888);
			Canvas canvas = new Canvas(bmp);
			// canvas.drawColor(android.graphics.Color.RED);
			FontMetrics fontMetrics = paint.getFontMetrics();
			float offsetX = 0;
			float singleLineHeight = (float) Math.ceil(fontMetrics.descent
					- fontMetrics.ascent);
			float fontPosY = titleHeight - (titleHeight - singleLineHeight)
					/ 2f - fontMetrics.bottom;
			canvas.drawText(displayTitle, offsetX, fontPosY, paint);
			return new TextureRegion(new BitmapTexture(bmp));
		}

		@Override
		public String formatDisplayTitle(String title, int titleWidth,
				int titleHeight) {
			// TODO Auto-generated method stub
			String tmpTitle = title;
			if (paint.measureText(tmpTitle) > titleWidth) {
				for (int i = 0; i < title.length() - 1; i++) {
					tmpTitle = title.substring(i);
					if (paint.measureText(tmpTitle) <= titleWidth) {
						break;
					}
				}
			}
			return tmpTitle;
		}

		@Override
		public void setPaint(Paint paint) {
			// TODO Auto-generated method stub
			this.paint = paint;
		}

	}

	/**
	 * The default {@link OnscreenKeyboard} used by all {@link TextField}
	 * instances. Just uses {@link Input#setOnscreenKeyboardVisible(boolean)} as
	 * appropriate. Might overlap your actual rendering, so use with care!
	 * 
	 * @author mzechner
	 */
	static public class DefaultOnscreenKeyboard implements OnscreenKeyboard {
		@Override
		public void show(boolean visible) {
			Gdx.input.setOnscreenKeyboardVisible(visible);
		}
	}

	/**
	 * The style for a text field, see {@link TextField}.
	 * 
	 * @author mzechner
	 */
	static public class TextFieldStyle {
		/** Optional. */
		public NinePatch background, cursor;
		public BitmapFont font;
		public Color fontColor;
		/** Optional. */
		public TextureRegion selection;
		/** Optional. */
		public BitmapFont messageFont;
		/** Optional. */
		public Color messageFontColor;

		public TextFieldStyle() {
		}

		public TextFieldStyle(BitmapFont font, Color fontColor,
				BitmapFont messageFont, Color messageFontColor,
				NinePatch cursor, TextureRegion selection, NinePatch background) {
			this.messageFont = messageFont;
			this.messageFontColor = messageFontColor;
			this.background = background;
			this.cursor = cursor;
			this.font = font;
			this.fontColor = fontColor;
			this.selection = selection;
		}
	}

	public void setText(String text) {
		this.text = text.trim();
		updateDisplayText();
		cursor = text.trim().length();
	}

	public void setTitleFontColor(int titleColor) {
		this.paint.setColor(titleColor);
		updateDisplayText();
	}

	@Override
	public void dispose() {
		// TODO Auto-generated method stub
		super.dispose();
		if (this.displayTextTexture != null) {
			if (displayTextTexture.getTexture() != null)
				displayTextTexture.getTexture().dispose();
		}
	}


}
